diff --git a/DEPS b/DEPS
index c98f944ee613..5f2098fd6329 100644
--- a/DEPS
+++ b/DEPS
@@ -168,7 +168,7 @@ vars = {
   # By default checkout the OpenXR loader library only on Windows and Android.
   # The OpenXR backend for VR in Chromium is currently only supported for these
   # platforms, but support for other platforms may be added in the future.
-  'checkout_openxr' : 'checkout_win or checkout_android',
+  'checkout_openxr' : 'checkout_win or checkout_linux or checkout_android',
 
   'checkout_instrumented_libraries': 'checkout_linux and checkout_configuration != "small"',
 
diff --git a/chrome/browser/vr/BUILD.gn b/chrome/browser/vr/BUILD.gn
index 1f60f1ea3438..05bf73f2d8f6 100644
--- a/chrome/browser/vr/BUILD.gn
+++ b/chrome/browser/vr/BUILD.gn
@@ -210,6 +210,17 @@ component("vr_common") {
       "//ui/gl/init",
     ]
   }
+
+  if (is_linux) {
+    sources += [
+      "graphics_delegate_linux.cc",
+      "graphics_delegate_linux.h",
+    ]
+
+    deps += [
+      "//services/viz/public/cpp/gpu",
+    ]
+  }
 }
 
 # vr_base contains common dependencies of vr_common and vr_ui. It exists because
diff --git a/chrome/browser/vr/graphics_delegate.cc b/chrome/browser/vr/graphics_delegate.cc
index b1b4bc0f6cd8..8794e124b922 100644
--- a/chrome/browser/vr/graphics_delegate.cc
+++ b/chrome/browser/vr/graphics_delegate.cc
@@ -22,6 +22,8 @@
 #include "chrome/browser/vr/graphics_delegate_win.h"
 #elif BUILDFLAG(IS_ANDROID)
 #include "chrome/browser/vr/graphics_delegate_android.h"
+#elif BUILDFLAG(IS_LINUX)
+#include "chrome/browser/vr/graphics_delegate_linux.h"
 #endif
 
 namespace vr {
@@ -66,6 +68,8 @@ std::unique_ptr<GraphicsDelegate> GraphicsDelegate::Create() {
   return std::make_unique<GraphicsDelegateWin>();
 #elif BUILDFLAG(IS_ANDROID)
   return std::make_unique<GraphicsDelegateAndroid>();
+#elif BUILDFLAG(IS_LINUX)
+  return std::make_unique<GraphicsDelegateLinux>();
 #else
   NOTIMPLEMENTED();
   return nullptr;
diff --git a/chrome/browser/vr/graphics_delegate_linux.cc b/chrome/browser/vr/graphics_delegate_linux.cc
new file mode 100644
index 000000000000..91b03c347dba
--- /dev/null
+++ b/chrome/browser/vr/graphics_delegate_linux.cc
@@ -0,0 +1,66 @@
+#include "chrome/browser/vr/graphics_delegate_linux.h"
+
+#include "content/public/browser/gpu_utils.h"
+#include "content/public/common/gpu_stream_constants.h"
+#include "gpu/command_buffer/client/gles2_lib.h"
+
+namespace vr {
+
+GraphicsDelegateLinux::GraphicsDelegateLinux() = default;
+GraphicsDelegateLinux::~GraphicsDelegateLinux() = default;
+
+void GraphicsDelegateLinux::Initialize(base::OnceClosure on_initialized) {
+  gpu::GpuChannelEstablishFactory* factory =
+      content::GetGpuChannelEstablishFactory();
+  gpu_channel_host_ = factory->EstablishGpuChannelSync();
+  gpu::ContextCreationAttribs attributes;
+  attributes.bind_generates_resource = false;
+  context_provider_ = base::MakeRefCounted<viz::ContextProviderCommandBuffer>(
+      gpu_channel_host_, content::kGpuStreamIdDefault,
+      content::kGpuStreamPriorityUI, gpu::kNullSurfaceHandle,
+      GURL(std::string("chrome://gpu/VrUiLinux")), false /* automatic flushes */,
+      false /* support locking */, gpu::SharedMemoryLimits::ForMailboxContext(),
+      attributes, viz::command_buffer_metrics::ContextType::XR_COMPOSITING);
+  if (context_provider_->BindToCurrentSequence() ==
+      gpu::ContextResult::kSuccess) {
+    gl_ = context_provider_->ContextGL();
+  }
+  std::move(on_initialized).Run(); // TODO: stub
+}
+
+bool GraphicsDelegateLinux::PreRender() {
+    return false; // TODO: stub
+}
+
+void GraphicsDelegateLinux::PostRender() {
+  ClearContext(); // TODO: stub
+}
+
+gfx::GpuMemoryBufferHandle GraphicsDelegateLinux::GetTexture() {
+  return gfx::GpuMemoryBufferHandle(); // TODO: stub
+}
+
+gpu::SyncToken GraphicsDelegateLinux::GetSyncToken() {
+  return {}; // TODO: stub
+}
+
+void GraphicsDelegateLinux::ResetMemoryBuffer() {} // TODO: stub
+
+bool GraphicsDelegateLinux::BindContext() {
+  if (!gl_)
+    return false;
+
+  ::gles2::SetGLContext(gl_);
+  return true;
+}
+
+void GraphicsDelegateLinux::ClearContext() {
+  ::gles2::SetGLContext(nullptr);
+}
+
+void GraphicsDelegateLinux::ClearBufferToBlack() {
+  gl_->ClearColor(0, 0, 0, 0);
+  gl_->Clear(GL_COLOR_BUFFER_BIT);
+}
+
+}  // namespace vr
diff --git a/chrome/browser/vr/graphics_delegate_linux.h b/chrome/browser/vr/graphics_delegate_linux.h
new file mode 100644
index 000000000000..f5df91dfebe0
--- /dev/null
+++ b/chrome/browser/vr/graphics_delegate_linux.h
@@ -0,0 +1,29 @@
+#pragma once
+#include "chrome/browser/vr/graphics_delegate.h"
+#include "gpu/command_buffer/client/gles2_interface.h"
+#include "gpu/ipc/client/gpu_channel_host.h"
+#include "services/viz/public/cpp/gpu/context_provider_command_buffer.h"
+
+namespace vr {
+
+class GraphicsDelegateLinux : public GraphicsDelegate {
+ public:
+  GraphicsDelegateLinux();
+  ~GraphicsDelegateLinux() override;
+  void Initialize(base::OnceClosure on_initialized) override;
+  bool PreRender() override;
+  void PostRender() override;
+  gfx::GpuMemoryBufferHandle GetTexture() override;
+  gpu::SyncToken GetSyncToken() override;
+  void ResetMemoryBuffer() override;
+  bool BindContext() override;
+  void ClearContext() override;
+ private:
+  void ClearBufferToBlack() override;
+
+  scoped_refptr<gpu::GpuChannelHost> gpu_channel_host_;
+  scoped_refptr<viz::ContextProviderCommandBuffer> context_provider_;
+  raw_ptr<gpu::gles2::GLES2Interface> gl_ = nullptr;
+};
+
+}  // namespace vr
diff --git a/content/services/isolated_xr_device/xr_runtime_provider.cc b/content/services/isolated_xr_device/xr_runtime_provider.cc
index e58956c59e41..5b6e810bc5d8 100644
--- a/content/services/isolated_xr_device/xr_runtime_provider.cc
+++ b/content/services/isolated_xr_device/xr_runtime_provider.cc
@@ -13,10 +13,14 @@
 #include "device/vr/buildflags/buildflags.h"
 #include "device/vr/public/cpp/features.h"
 
-#if BUILDFLAG(ENABLE_OPENXR) && BUILDFLAG(IS_WIN)
+#if BUILDFLAG(ENABLE_OPENXR) && (BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX))
 #include "content/public/common/gpu_stream_constants.h"
 #include "device/vr/openxr/openxr_device.h"
+#if BUILDFLAG(IS_WIN)
 #include "device/vr/openxr/windows/openxr_platform_helper_windows.h"
+#else
+#include "device/vr/openxr/linux/openxr_platform_helper_linux.h"
+#endif
 #include "services/viz/public/cpp/gpu/context_provider_command_buffer.h"
 #endif
 
@@ -97,7 +101,7 @@ void IsolatedXRRuntimeProvider::PollForDeviceChanges() {
   // 'preferred_device_enabled' being unused, thus [[maybe_unused]].
   [[maybe_unused]] bool preferred_device_enabled = false;
 
-#if BUILDFLAG(ENABLE_OPENXR) && BUILDFLAG(IS_WIN)
+#if BUILDFLAG(ENABLE_OPENXR) && (BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX))
   if (!preferred_device_enabled && IsOpenXrHardwareAvailable()) {
     SetOpenXrRuntimeStatus(RuntimeStatus::kEnable);
     preferred_device_enabled = true;
@@ -121,11 +125,16 @@ void IsolatedXRRuntimeProvider::SetupPollingForDeviceChanges() {
   // If none of the following runtimes are enabled, we'll get an error for
   // 'command_line' being unused, thus [[maybe_unused]].
 
-#if BUILDFLAG(ENABLE_OPENXR) && BUILDFLAG(IS_WIN)
+#if BUILDFLAG(ENABLE_OPENXR) && (BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX))
   if (IsEnabled(command_line, device::features::kOpenXR,
                 switches::kWebXrRuntimeOpenXr)) {
+    #if BUILDFLAG(IS_WIN)
     openxr_platform_helper_ =
         std::make_unique<device::OpenXrPlatformHelperWindows>();
+    #else
+    openxr_platform_helper_ =
+        std::make_unique<device::OpenXrPlatformHelperLinux>();
+    #endif
     should_check_openxr_ = openxr_platform_helper_->EnsureInitialized() &&
                            openxr_platform_helper_->IsApiAvailable();
     any_runtimes_available |= should_check_openxr_;
@@ -147,7 +156,7 @@ void IsolatedXRRuntimeProvider::RequestDevices(
   client_->OnDevicesEnumerated();
 }
 
-#if BUILDFLAG(ENABLE_OPENXR) && BUILDFLAG(IS_WIN)
+#if BUILDFLAG(ENABLE_OPENXR) && (BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX))
 bool IsolatedXRRuntimeProvider::IsOpenXrHardwareAvailable() {
   return should_check_openxr_ && openxr_platform_helper_->IsHardwareAvailable();
 }
diff --git a/content/services/isolated_xr_device/xr_runtime_provider.h b/content/services/isolated_xr_device/xr_runtime_provider.h
index b634ec19d8c8..323b21c7ec38 100644
--- a/content/services/isolated_xr_device/xr_runtime_provider.h
+++ b/content/services/isolated_xr_device/xr_runtime_provider.h
@@ -21,7 +21,13 @@
 #include "services/viz/public/cpp/gpu/gpu.h"
 #endif
 
-#if BUILDFLAG(ENABLE_OPENXR) && BUILDFLAG(IS_WIN)
+#if BUILDFLAG(ENABLE_OPENXR) && BUILDFLAG(IS_LINUX)
+#include "components/viz/common/gpu/context_provider.h"
+#include "device/vr/openxr/context_provider_callbacks.h"
+#include "device/vr/openxr/linux/openxr_platform_helper_linux.h"
+#include "services/viz/public/cpp/gpu/gpu.h"
+#endif
+
 namespace device {
 class OpenXrDevice;
 }  // namespace device
@@ -29,7 +35,6 @@ class OpenXrDevice;
 namespace viz {
 class Gpu;
 }  // namespace viz
-#endif
 
 class IsolatedXRRuntimeProvider final
     : public device::mojom::IsolatedXRRuntimeProvider {
@@ -50,7 +55,7 @@ class IsolatedXRRuntimeProvider final
   void PollForDeviceChanges();
   void SetupPollingForDeviceChanges();
 
-#if BUILDFLAG(ENABLE_OPENXR) && BUILDFLAG(IS_WIN)
+#if BUILDFLAG(ENABLE_OPENXR) && (BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX))
   bool IsOpenXrHardwareAvailable();
   void SetOpenXrRuntimeStatus(RuntimeStatus status);
   void CreateContextProviderAsync(
@@ -59,7 +64,11 @@ class IsolatedXRRuntimeProvider final
   bool should_check_openxr_ = false;
 
   // Must outlive OpenXrDevice
+  #if BUILDFLAG(IS_WIN)
   std::unique_ptr<device::OpenXrPlatformHelperWindows> openxr_platform_helper_;
+  #else
+  std::unique_ptr<device::OpenXrPlatformHelperLinux> openxr_platform_helper_;
+  #endif
 
   std::unique_ptr<device::OpenXrDevice> openxr_device_;
 
diff --git a/device/vr/BUILD.gn b/device/vr/BUILD.gn
index 15df8abbb8d6..ea87fbe4cb3e 100644
--- a/device/vr/BUILD.gn
+++ b/device/vr/BUILD.gn
@@ -246,6 +246,19 @@ if (enable_vr) {
         deps += [ ":directx_helpers" ]
       }
 
+      if (is_linux) {
+        libs = [ ]
+
+        sources += [
+          "openxr/linux/openxr_graphics_binding_vulkan.cc",
+          "openxr/linux/openxr_graphics_binding_vulkan.h",
+          "openxr/linux/openxr_platform_helper_linux.cc",
+          "openxr/linux/openxr_platform_helper_linux.h",
+        ]
+
+        configs += [ "//gpu/vulkan:vulkan_config" ]
+      }
+
       if (is_android) {
         sources += [
           "openxr/android/openxr_anchor_manager_android.cc",
diff --git a/device/vr/buildflags/buildflags.gni b/device/vr/buildflags/buildflags.gni
index 1c0b7ac1023d..1a65da15eb48 100644
--- a/device/vr/buildflags/buildflags.gni
+++ b/device/vr/buildflags/buildflags.gni
@@ -20,11 +20,11 @@ declare_args() {
 
   enable_arcore = _is_xr_supported_android
 
-  use_command_buffer = is_win
+  use_command_buffer = is_win || is_linux
 
   # To build with OpenXR support, the OpenXR Loader needs to be pulled to
   # third_party/openxr.
-  enable_openxr = checkout_openxr && (is_win || _is_xr_supported_android)
+  enable_openxr = checkout_openxr && (is_win || is_linux || _is_xr_supported_android)
 }
 
 declare_args() {
diff --git a/device/vr/openxr/linux/openxr_graphics_binding_vulkan.cc b/device/vr/openxr/linux/openxr_graphics_binding_vulkan.cc
new file mode 100644
index 000000000000..3d9e9e5507d2
--- /dev/null
+++ b/device/vr/openxr/linux/openxr_graphics_binding_vulkan.cc
@@ -0,0 +1,384 @@
+#include "device/vr/openxr/linux/openxr_graphics_binding_vulkan.h"
+#include "base/containers/contains.h"
+#include "base/native_library.h"
+#include "device/vr/openxr/openxr_util.h"
+#include "components/viz/common/gpu/context_provider.h"
+#include "gpu/command_buffer/common/shared_image_usage.h"
+#include "gpu/ipc/common/gpu_memory_buffer_support.h"
+#include "gpu/vulkan/vulkan_function_pointers.h"
+#include "ui/gfx/color_space.h"
+
+namespace device {
+
+namespace {
+  [[maybe_unused]] int next_memory_buffer_id = 0;
+}
+
+void OpenXrGraphicsBinding::GetRequiredExtensions(std::vector<const char*>& extensions) {
+  extensions.push_back(XR_KHR_VULKAN_ENABLE2_EXTENSION_NAME);
+}
+
+OpenXrGraphicsBindingVulkan::OpenXrGraphicsBindingVulkan() = default;
+OpenXrGraphicsBindingVulkan::~OpenXrGraphicsBindingVulkan() {
+  if (initialized_)
+    vkDeviceWaitIdle(binding_.device);
+  if (commandBuffer_)
+    commandBuffer_->Destroy();
+  commandBuffer_.reset();
+  if (commandPool_)
+    commandPool_->Destroy();
+  commandPool_.reset();
+  if (copyQueue_)
+    copyQueue_->Destroy();
+  copyQueue_.reset();
+  if (binding_.device)
+    vkDestroyDevice(binding_.device, nullptr);
+}
+
+struct StaticLibrary {
+  base::NativeLibrary handle;
+  StaticLibrary(base::NativeLibrary library) : handle(library) {}
+  // ~StaticLibrary() {base::UnloadNativeLibrary(handle);} // no exit-time destructor
+  operator base::NativeLibrary() const {return handle;}
+};
+
+static base::NativeLibrary LoadNativeLibrary(std::string_view filePath) {
+  base::NativeLibraryLoadError error;
+  base::NativeLibrary library = base::LoadNativeLibrary(base::FilePath(filePath), &error);
+  if (!library)
+      LOG(ERROR) << "Failed to load '" << filePath << "': " << error.ToString();
+  return library;
+}
+
+XrResult OpenXrGraphicsBindingVulkan::SetupBinding(XrInstance instance, XrSystemId system) {
+  static StaticLibrary libvulkan = LoadNativeLibrary("libvulkan.so.1");
+  gpu::VulkanFunctionPointers *const vulkan_function_pointers = gpu::GetVulkanFunctionPointers();
+  vulkan_function_pointers->ResetForTesting();
+  if (!vulkan_function_pointers->BindUnassociatedFunctionPointersFromLoaderLib(libvulkan))
+    return XR_ERROR_RUNTIME_FAILURE;
+
+  PFN_xrGetVulkanGraphicsRequirements2KHR pfn_xrGetVulkanGraphicsRequirements2KHR = nullptr;
+  RETURN_IF_XR_FAILED(xrGetInstanceProcAddr(instance, "xrGetVulkanGraphicsRequirements2KHR", (PFN_xrVoidFunction*)(&pfn_xrGetVulkanGraphicsRequirements2KHR)));
+  PFN_xrCreateVulkanInstanceKHR pfn_xrCreateVulkanInstanceKHR = nullptr;
+  RETURN_IF_XR_FAILED(xrGetInstanceProcAddr(instance, "xrCreateVulkanInstanceKHR", (PFN_xrVoidFunction*)(&pfn_xrCreateVulkanInstanceKHR)));
+  PFN_xrGetVulkanGraphicsDevice2KHR pfn_xrGetVulkanGraphicsDevice2KHR = nullptr;
+  RETURN_IF_XR_FAILED(xrGetInstanceProcAddr(instance, "xrGetVulkanGraphicsDevice2KHR", (PFN_xrVoidFunction*)(&pfn_xrGetVulkanGraphicsDevice2KHR)));
+  PFN_xrCreateVulkanDeviceKHR pfn_xrCreateVulkanDeviceKHR = nullptr;
+  RETURN_IF_XR_FAILED(xrGetInstanceProcAddr(instance, "xrCreateVulkanDeviceKHR", (PFN_xrVoidFunction*)(&pfn_xrCreateVulkanDeviceKHR)));
+
+  XrGraphicsRequirementsVulkan2KHR requirements = {XR_TYPE_GRAPHICS_REQUIREMENTS_VULKAN2_KHR};
+  RETURN_IF_XR_FAILED(pfn_xrGetVulkanGraphicsRequirements2KHR(instance, system, &requirements));
+  VkResult result;
+  RETURN_IF_XR_FAILED(pfn_xrCreateVulkanInstanceKHR(instance, (const XrVulkanInstanceCreateInfoKHR[1]){{
+    .type = XR_TYPE_VULKAN_INSTANCE_CREATE_INFO_KHR,
+    .systemId = system,
+    .pfnGetInstanceProcAddr = vulkan_function_pointers->vkGetInstanceProcAddr.get(),
+    .vulkanCreateInfo = (const VkInstanceCreateInfo[1]){{
+      .sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO,
+      .pApplicationInfo = (const VkApplicationInfo[1]){{
+        .sType = VK_STRUCTURE_TYPE_APPLICATION_INFO,
+        .pApplicationName = "Chromium",
+        .apiVersion = gpu::kVulkanRequiredApiVersion,
+      }},
+      /*.enabledLayerCount = 1,
+      .ppEnabledLayerNames = (const char *const[1]){
+        "VK_LAYER_KHRONOS_validation",
+      },*/
+    }},
+  }}, &binding_.instance, &result));
+  RETURN_IF(result < VK_SUCCESS, XR_ERROR_RUNTIME_FAILURE, "xrCreateVulkanInstanceKHR() failed");
+
+  std::vector<const char*> extensions = {
+    VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME,
+    VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME,
+    VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME,
+    VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME,
+    VK_EXT_EXTERNAL_MEMORY_DMA_BUF_EXTENSION_NAME,
+  };
+  if (haveDrmFormatModifiers_) // TODO: set `haveDrmFormatModifiers_` if supported
+    extensions.push_back(VK_EXT_IMAGE_DRM_FORMAT_MODIFIER_EXTENSION_NAME);
+  gfx::ExtensionSet extension_set(std::begin(extensions), std::end(extensions));
+
+  if (!vulkan_function_pointers->BindInstanceFunctionPointers(binding_.instance, gpu::kVulkanRequiredApiVersion, extension_set))
+    return XR_ERROR_RUNTIME_FAILURE;
+
+  RETURN_IF_XR_FAILED(pfn_xrGetVulkanGraphicsDevice2KHR(instance, (const XrVulkanGraphicsDeviceGetInfoKHR[1]){{
+    .type = XR_TYPE_VULKAN_GRAPHICS_DEVICE_GET_INFO_KHR,
+    .systemId = system,
+    .vulkanInstance = binding_.instance,
+  }}, &binding_.physicalDevice));
+
+  const float queuePriority = 0;
+  VkDeviceQueueCreateInfo queueInfo = {
+    .sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
+    .queueCount = 1,
+    .pQueuePriorities = &queuePriority,
+  };
+  uint32_t queueFamilyCount = 0;
+  vkGetPhysicalDeviceQueueFamilyProperties(binding_.physicalDevice, &queueFamilyCount, nullptr);
+  std::vector<VkQueueFamilyProperties> queueFamilyProps(queueFamilyCount);
+  vkGetPhysicalDeviceQueueFamilyProperties(binding_.physicalDevice, &queueFamilyCount, &queueFamilyProps[0]);
+
+  for (uint32_t i = 0; i < queueFamilyCount; ++i) {
+    if (queueFamilyProps[i].queueFlags & VK_QUEUE_GRAPHICS_BIT) {
+      binding_.queueFamilyIndex = i;
+      break;
+    }
+  }
+  queueInfo.queueFamilyIndex = binding_.queueFamilyIndex;
+
+  RETURN_IF_XR_FAILED(pfn_xrCreateVulkanDeviceKHR(instance, (const XrVulkanDeviceCreateInfoKHR[1]){{
+    .type = XR_TYPE_VULKAN_DEVICE_CREATE_INFO_KHR,
+    .systemId = system,
+    .pfnGetInstanceProcAddr = vulkan_function_pointers->vkGetInstanceProcAddr.get(),
+    .vulkanPhysicalDevice = binding_.physicalDevice,
+    .vulkanCreateInfo = (const VkDeviceCreateInfo[1]){{
+      .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
+      .queueCreateInfoCount = 1,
+      .pQueueCreateInfos = &queueInfo,
+      .enabledExtensionCount = (uint32_t)extensions.size(),
+      .ppEnabledExtensionNames = &extensions[0],
+      .pEnabledFeatures = (const VkPhysicalDeviceFeatures[1]){},
+    }},
+  }}, &binding_.device, &result));
+  RETURN_IF(result < VK_SUCCESS, XR_ERROR_RUNTIME_FAILURE, "xrCreateVulkanDeviceKHR() failed");
+  if (!vulkan_function_pointers->BindDeviceFunctionPointers(binding_.device, gpu::kVulkanRequiredApiVersion, extension_set))
+    return XR_ERROR_RUNTIME_FAILURE;
+  pfn_vkCmdCopyImage_ = reinterpret_cast<PFN_vkCmdCopyImage>(vkGetDeviceProcAddr(binding_.device, "vkCmdCopyImage"));
+  if (!pfn_vkCmdCopyImage_) {
+    DLOG(WARNING) << "Failed to bind vulkan entrypoint: vkCmdCopyImage";
+    return XR_ERROR_RUNTIME_FAILURE;
+  }
+  pfn_vkCmdClearColorImage_ = reinterpret_cast<PFN_vkCmdClearColorImage>(vkGetDeviceProcAddr(binding_.device, "vkCmdClearColorImage"));
+  if (!pfn_vkCmdClearColorImage_) {
+    DLOG(WARNING) << "Failed to bind vulkan entrypoint: vkCmdClearColorImage";
+    return XR_ERROR_RUNTIME_FAILURE;
+  }
+
+  binding_.queueIndex = 0;
+  VkQueue queue = VK_NULL_HANDLE;
+  vkGetDeviceQueue(binding_.device, binding_.queueFamilyIndex, binding_.queueIndex, &queue);
+  copyQueue_ = std::make_unique<gpu::VulkanDeviceQueue>(binding_.instance);
+  if (!copyQueue_->InitializeForWebView(binding_.physicalDevice, binding_.device, queue, binding_.queueFamilyIndex, std::move(extension_set)))
+    return XR_ERROR_RUNTIME_FAILURE;
+  commandPool_ = std::make_unique<gpu::VulkanCommandPool>(copyQueue_.get());
+  if (!commandPool_->Initialize()) // vkCreateCommandPool
+    return XR_ERROR_RUNTIME_FAILURE;
+  commandBuffer_ = commandPool_->CreatePrimaryCommandBuffer(); // vkAllocateCommandBuffers
+  if (!commandBuffer_)
+    return XR_ERROR_RUNTIME_FAILURE;
+  return XR_SUCCESS;
+}
+
+bool OpenXrGraphicsBindingVulkan::Initialize(XrInstance instance, XrSystemId system) {
+  initialized_ = initialized_ || !XR_FAILED(SetupBinding(instance, system));
+  return initialized_;
+}
+
+const void* OpenXrGraphicsBindingVulkan::GetSessionCreateInfo() const {
+  CHECK(initialized_);
+  return &binding_;
+}
+
+int64_t OpenXrGraphicsBindingVulkan::GetSwapchainFormat(XrSession session) const {
+  uint32_t format_length = 0;
+  RETURN_IF_XR_FAILED(xrEnumerateSwapchainFormats(session, 0, &format_length, nullptr));
+  std::vector<int64_t> swapchain_formats(format_length);
+  RETURN_IF_XR_FAILED(xrEnumerateSwapchainFormats(session, (uint32_t)swapchain_formats.size(), &format_length, swapchain_formats.data()));
+  DCHECK(!swapchain_formats.empty());
+
+  if (base::Contains(swapchain_formats, VK_FORMAT_B8G8R8A8_SRGB))
+    return VK_FORMAT_B8G8R8A8_SRGB;
+
+  if (!base::Contains(swapchain_formats, VK_FORMAT_B8G8R8A8_UNORM)) {
+    LOG(ERROR) << "No matching supported swapchain formats with OpenXr Runtime:";
+    for(int64_t format : swapchain_formats)
+      LOG(ERROR) << "    " << format;
+  }
+
+  return VK_FORMAT_B8G8R8A8_UNORM;
+}
+
+XrResult OpenXrGraphicsBindingVulkan::EnumerateSwapchainImages(const XrSwapchain& color_swapchain) {
+  CHECK(color_swapchain != XR_NULL_HANDLE);
+  CHECK(color_swapchain_images_.empty());
+
+  uint32_t chain_length;
+  RETURN_IF_XR_FAILED(xrEnumerateSwapchainImages(color_swapchain, 0, &chain_length, nullptr));
+  std::vector<XrSwapchainImageVulkan2KHR> xr_swapchain_images(chain_length, {XR_TYPE_SWAPCHAIN_IMAGE_VULKAN2_KHR});
+
+  RETURN_IF_XR_FAILED(xrEnumerateSwapchainImages(color_swapchain, xr_swapchain_images.size(), &chain_length, reinterpret_cast<XrSwapchainImageBaseHeader*>(xr_swapchain_images.data())));
+
+  color_swapchain_images_.reserve(xr_swapchain_images.size());
+  for (const XrSwapchainImageVulkan2KHR& swapchain_image : xr_swapchain_images) {
+    color_swapchain_images_.emplace_back(swapchain_image.image);
+  }
+
+  return XR_SUCCESS;
+}
+
+void OpenXrGraphicsBindingVulkan::ClearSwapchainImages() {
+  vkDeviceWaitIdle(binding_.device);
+  for (auto& swap_chain_info : color_swapchain_images_) {
+    if (swap_chain_info.local_vkimage == nullptr)
+      continue;
+    swap_chain_info.local_vkimage->Destroy();
+    swap_chain_info.local_vkimage.reset();
+  }
+  color_swapchain_images_.clear();
+}
+
+base::span<SwapChainInfo> OpenXrGraphicsBindingVulkan::GetSwapChainImages() {
+  return color_swapchain_images_;
+}
+
+bool OpenXrGraphicsBindingVulkan::CanUseSharedImages() const {
+  return true;
+}
+
+void OpenXrGraphicsBindingVulkan::ResizeSharedBuffer(SwapChainInfo& swap_chain_info, gpu::SharedImageInterface* sii) {
+  CHECK(sii);
+  auto transfer_size = GetTransferSize();
+  if (swap_chain_info.shared_buffer_size == transfer_size)
+    return;
+
+  if (swap_chain_info.shared_image.get() != nullptr) {
+    DVLOG(2) << ": DestroySharedImage, mailbox=" << swap_chain_info.shared_image->mailbox().ToDebugString();
+    sii->DestroySharedImage(swap_chain_info.sync_token, std::move(swap_chain_info.shared_image));
+  }
+  if (swap_chain_info.local_vkimage != nullptr) {
+    vkDeviceWaitIdle(binding_.device);
+    swap_chain_info.local_vkimage->Destroy();
+    swap_chain_info.local_vkimage.reset();
+  }
+
+  const VkExternalMemoryImageCreateInfo extra_image_create_info = {
+    .sType = VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO,
+    .handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
+  };
+  const VkExportMemoryAllocateInfo extra_memory_allocation_info = {
+    .sType = VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO,
+    .handleTypes = VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT,
+  };
+  std::unique_ptr<gpu::VulkanImage> backingImage = gpu::VulkanImage::Create(copyQueue_.get(), transfer_size, VK_FORMAT_B8G8R8A8_UNORM, VK_IMAGE_USAGE_TRANSFER_SRC_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT, 0,
+    haveDrmFormatModifiers_ ? VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT : VK_IMAGE_TILING_OPTIMAL, &extra_image_create_info, &extra_memory_allocation_info);
+
+  base::ScopedFD fd = backingImage->GetMemoryFd(VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT);
+  if (!fd.is_valid()) {
+    LOG(ERROR) << "vkGetMemoryFdKHR() failed";
+    backingImage->Destroy();
+    backingImage.reset(); // TODO: std::move
+    return;
+  }
+
+  VkImageDrmFormatModifierPropertiesEXT modifier_props = {
+    .sType = VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT,
+    .drmFormatModifier = gfx::NativePixmapHandle::kNoModifier,
+  };
+  if (haveDrmFormatModifiers_) {
+    const VkResult result = vkGetImageDrmFormatModifierPropertiesEXT(binding_.device, backingImage->image(), &modifier_props);
+    if (result != VK_SUCCESS) {
+      LOG(ERROR) << "vkGetImageDrmFormatModifierPropertiesEXT failed result:" << result;
+      backingImage->Destroy();
+      backingImage.reset();
+      return;
+    }
+  }
+
+  gfx::GpuMemoryBufferHandle handle = {};
+  handle.id = gfx::GpuMemoryBufferId(next_memory_buffer_id++);
+  handle.type = gfx::GpuMemoryBufferType::NATIVE_PIXMAP;
+  handle.native_pixmap_handle.planes.emplace_back(0, 0, backingImage->device_size(), std::move(fd));
+  handle.native_pixmap_handle.modifier = modifier_props.drmFormatModifier;
+
+  swap_chain_info.shared_image = sii->CreateSharedImage({
+    viz::SinglePlaneFormat::kBGRA_8888,
+    transfer_size,
+    gfx::ColorSpace(),
+    gpu::SHARED_IMAGE_USAGE_GLES2_READ | gpu::SHARED_IMAGE_USAGE_GLES2_WRITE,
+    "OpenXrGraphicsBindingVulkan",
+  }, std::move(handle));
+  CHECK(swap_chain_info.shared_image);
+  swap_chain_info.sync_token = sii->GenVerifiedSyncToken();
+  swap_chain_info.local_vkimage = std::move(backingImage);
+  backingImage.reset();
+}
+
+void OpenXrGraphicsBindingVulkan::CreateSharedImages(gpu::SharedImageInterface* sii) {
+  CHECK(sii);
+  using_shared_images_ = true;
+
+  for (auto& swap_chain_info : color_swapchain_images_)
+    ResizeSharedBuffer(swap_chain_info, sii);
+}
+
+const SwapChainInfo& OpenXrGraphicsBindingVulkan::GetActiveSwapchainImage() {
+  CHECK(has_active_swapchain_image());
+  CHECK(active_swapchain_index() < color_swapchain_images_.size());
+  return color_swapchain_images_[active_swapchain_index()];
+}
+
+void OpenXrGraphicsBindingVulkan::CleanupWithoutSubmit() {}
+
+bool OpenXrGraphicsBindingVulkan::WaitOnFence(gfx::GpuFence& gpu_fence) {
+  return false;
+}
+
+bool OpenXrGraphicsBindingVulkan::ShouldFlipSubmittedImage() {
+  return true;
+}
+
+void OpenXrGraphicsBindingVulkan::OnSwapchainImageActivated(gpu::SharedImageInterface* sii) {
+  CHECK(has_active_swapchain_image());
+  CHECK(active_swapchain_index() < color_swapchain_images_.size());
+  CHECK(using_shared_images_);
+  ResizeSharedBuffer(color_swapchain_images_[active_swapchain_index()], sii);
+}
+
+void OpenXrGraphicsBindingVulkan::SetOverlayAndWebXrVisibility(bool overlay_visible, bool webxr_visible) {
+  if (!overlay_visible_ && overlay_visible)
+    LOG(WARNING) << "Overlay compositing not implemented yet; overlay will not be visible";
+  webxr_visible_ = webxr_visible;
+  overlay_visible_ = overlay_visible;
+}
+
+bool OpenXrGraphicsBindingVulkan::SetOverlayTexture(gfx::GpuMemoryBufferHandle texture, const gpu::SyncToken& sync_token, const gfx::RectF& left, const gfx::RectF& right) {
+    return false; // TODO: overlay support
+}
+
+bool OpenXrGraphicsBindingVulkan::Render(const scoped_refptr<viz::ContextProvider>& context_provider) {
+  const gfx::Size imageSize = GetTransferSize();
+  SwapChainInfo &image = color_swapchain_images_[active_swapchain_index()];
+  commandBuffer_->Wait(UINT64_MAX);
+  if (imageSize != GetSwapchainImageSize() || image.local_vkimage == nullptr)
+    return false;
+  {
+    gpu::ScopedSingleUseCommandBufferRecorder recorder(*commandBuffer_); // vkBeginCommandBuffer
+    if (webxr_visible_) {
+      commandBuffer_->TransitionImageLayout(image.local_vkimage->image(), VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL);
+      commandBuffer_->TransitionImageLayout(image.openxr_image, VK_IMAGE_LAYOUT_UNDEFINED, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
+      pfn_vkCmdCopyImage_(recorder.handle(), image.local_vkimage->image(), VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, image.openxr_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, (const VkImageCopy[1]){{
+        .srcSubresource = {
+          .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
+          .layerCount = 1,
+        },
+        .dstSubresource = {
+          .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
+          .layerCount = 1,
+        },
+        .extent = {(uint32_t)imageSize.width(), (uint32_t)imageSize.height(), 1},
+      }});
+      commandBuffer_->TransitionImageLayout(image.local_vkimage->image(), VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL);
+      commandBuffer_->TransitionImageLayout(image.openxr_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL);
+    } else {
+      pfn_vkCmdClearColorImage_(recorder.handle(), image.openxr_image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, (const VkClearColorValue[1]){}, 1, (const VkImageSubresourceRange[1]){{
+        .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
+        .layerCount = 1,
+      }});
+    }
+  } // ~CommandBufferRecorderBase() - vkEndCommandBuffer
+  commandBuffer_->Submit(0, nullptr, 0, nullptr);
+  return true; // TODO: move blit logic here
+}
+
+} // namespace device
diff --git a/device/vr/openxr/linux/openxr_graphics_binding_vulkan.h b/device/vr/openxr/linux/openxr_graphics_binding_vulkan.h
new file mode 100644
index 000000000000..02c83c39e19b
--- /dev/null
+++ b/device/vr/openxr/linux/openxr_graphics_binding_vulkan.h
@@ -0,0 +1,58 @@
+#pragma once
+#include <vector>
+
+#include "device/vr/openxr/openxr_graphics_binding.h"
+#include "device/vr/openxr/openxr_platform.h"
+#include "device/vr/vr_export.h"
+#include "gpu/command_buffer/client/gles2_interface.h"
+#include "gpu/command_buffer/client/shared_image_interface.h"
+#include "gpu/vulkan/vulkan_command_buffer.h"
+#include "gpu/vulkan/vulkan_command_pool.h"
+#include "gpu/vulkan/vulkan_device_queue.h"
+#include "ui/gfx/gpu_memory_buffer.h"
+
+namespace device {
+
+class DEVICE_VR_EXPORT OpenXrGraphicsBindingVulkan : public OpenXrGraphicsBinding {
+ public:
+  OpenXrGraphicsBindingVulkan();
+  ~OpenXrGraphicsBindingVulkan() override;
+
+  bool Initialize(XrInstance instance, XrSystemId system) override;
+  const void* GetSessionCreateInfo() const override;
+  int64_t GetSwapchainFormat(XrSession session) const override;
+  XrResult EnumerateSwapchainImages(
+      const XrSwapchain& color_swapchain) override;
+  void ClearSwapchainImages() override;
+  base::span<SwapChainInfo> GetSwapChainImages() override;
+  bool CanUseSharedImages() const override;
+  void CreateSharedImages(gpu::SharedImageInterface* sii) override;
+  const SwapChainInfo& GetActiveSwapchainImage() override;
+  void CleanupWithoutSubmit() override;
+  bool WaitOnFence(gfx::GpuFence& gpu_fence) override;
+  bool ShouldFlipSubmittedImage() override;
+  void SetOverlayAndWebXrVisibility(bool overlay_visible, bool webxr_visible) override;
+  bool SetOverlayTexture(gfx::GpuMemoryBufferHandle texture, const gpu::SyncToken& sync_token, const gfx::RectF& left, const gfx::RectF& right) override;
+  bool Render(const scoped_refptr<viz::ContextProvider>& context_provider) override;
+
+private:
+  void ResizeSharedBuffer(SwapChainInfo& swap_chain_info, gpu::SharedImageInterface* sii);
+  XrResult SetupBinding(XrInstance instance, XrSystemId system);
+  void OnSwapchainImageActivated(gpu::SharedImageInterface* sii) override;
+  bool initialized_ = false;
+  bool haveDrmFormatModifiers_ = false;
+  bool using_shared_images_ = false;
+  bool webxr_visible_ = true;
+  bool overlay_visible_ = false;
+  XrGraphicsBindingVulkan2KHR binding_{XR_TYPE_GRAPHICS_BINDING_VULKAN2_KHR, nullptr};
+  std::vector<SwapChainInfo> color_swapchain_images_;
+
+  std::unique_ptr<gpu::VulkanDeviceQueue> copyQueue_ = nullptr;
+  std::unique_ptr<gpu::VulkanCommandPool> commandPool_ = nullptr;
+  std::unique_ptr<gpu::VulkanCommandBuffer> commandBuffer_ = nullptr;
+
+  PFN_vkCmdCopyImage pfn_vkCmdCopyImage_ = nullptr;
+  PFN_vkCmdClearColorImage pfn_vkCmdClearColorImage_ = nullptr;
+};
+
+}  // namespace device
diff --git a/device/vr/openxr/linux/openxr_platform_helper_linux.cc b/device/vr/openxr/linux/openxr_platform_helper_linux.cc
new file mode 100644
index 000000000000..fb3e287dc92b
--- /dev/null
+++ b/device/vr/openxr/linux/openxr_platform_helper_linux.cc
@@ -0,0 +1,63 @@
+#include "device/vr/openxr/linux/openxr_platform_helper_linux.h"
+#include "device/vr/openxr/openxr_api_wrapper.h"
+#include "device/vr/openxr/linux/openxr_graphics_binding_vulkan.h"
+#include "device/vr/public/mojom/isolated_xr_service.mojom.h"
+
+namespace device {
+
+void OpenXrPlatformHelper::GetRequiredExtensions(std::vector<const char*>& extensions) {}
+std::vector<const char*> OpenXrPlatformHelper::GetOptionalExtensions() {return {};}
+
+OpenXrPlatformHelperLinux::OpenXrPlatformHelperLinux() {}
+OpenXrPlatformHelperLinux::~OpenXrPlatformHelperLinux() = default;
+
+std::unique_ptr<OpenXrGraphicsBinding> OpenXrPlatformHelperLinux::GetGraphicsBinding() {
+  return std::make_unique<OpenXrGraphicsBindingVulkan>();
+}
+
+void OpenXrPlatformHelperLinux::GetPlatformCreateInfo(const device::OpenXrCreateInfo& create_info, PlatformCreateInfoReadyCallback callback, PlatormInitiatedShutdownCallback) {
+  std::move(callback).Run(nullptr);
+}
+
+device::mojom::XRDeviceData OpenXrPlatformHelperLinux::GetXRDeviceData() {
+  return {};
+}
+
+bool OpenXrPlatformHelperLinux::IsHardwareAvailable() {
+  XrInstance instance = GetOrCreateXrInstance();
+  if (instance == XR_NULL_HANDLE) {
+    return false;
+  }
+
+  XrSystemId system;
+  return XR_SUCCEEDED(OpenXrApiWrapper::GetSystem(instance, &system));
+}
+
+bool OpenXrPlatformHelperLinux::IsApiAvailable() {
+  return GetOrCreateXrInstance() != XR_NULL_HANDLE;
+}
+
+bool OpenXrPlatformHelperLinux::Initialize() {
+  return true;
+}
+
+XrInstance OpenXrPlatformHelperLinux::GetOrCreateXrInstance() {
+  XrInstance instance = XR_NULL_HANDLE;
+  (void)CreateInstance(&instance, nullptr);
+  return instance;
+}
+
+XrResult OpenXrPlatformHelperLinux::CreateInstance(XrInstance* instance, void* create_info) {
+  CHECK(instance);
+  if (xr_instance_ != XR_NULL_HANDLE) {
+    *instance = xr_instance_;
+    return XR_SUCCESS;
+  }
+  return OpenXrPlatformHelper::CreateInstance(instance, create_info);
+}
+
+XrResult OpenXrPlatformHelperLinux::DestroyInstance(XrInstance& instance) {
+  return OpenXrPlatformHelper::DestroyInstance(instance);
+}
+
+}  // namespace device
diff --git a/device/vr/openxr/linux/openxr_platform_helper_linux.h b/device/vr/openxr/linux/openxr_platform_helper_linux.h
new file mode 100644
index 000000000000..17e060c8968f
--- /dev/null
+++ b/device/vr/openxr/linux/openxr_platform_helper_linux.h
@@ -0,0 +1,27 @@
+#pragma once
+#include "device/vr/openxr/openxr_platform_helper.h"
+#include "device/vr/openxr/openxr_platform.h"
+
+namespace device {
+
+class DEVICE_VR_EXPORT OpenXrPlatformHelperLinux : public OpenXrPlatformHelper {
+ public:
+  OpenXrPlatformHelperLinux();
+  ~OpenXrPlatformHelperLinux() override;
+
+  std::unique_ptr<OpenXrGraphicsBinding> GetGraphicsBinding() override;
+  void GetPlatformCreateInfo(const device::OpenXrCreateInfo& create_info, PlatformCreateInfoReadyCallback, PlatormInitiatedShutdownCallback) override;
+  device::mojom::XRDeviceData GetXRDeviceData() override;
+  bool Initialize() override;
+
+  XrResult CreateInstance(XrInstance* instance, void* create_info) override;
+  XrResult DestroyInstance(XrInstance& instance) override;
+
+  bool IsHardwareAvailable();
+  bool IsApiAvailable();
+
+private:
+  XrInstance GetOrCreateXrInstance();
+};
+
+}
diff --git a/device/vr/openxr/openxr_extension_handler_factories.cc b/device/vr/openxr/openxr_extension_handler_factories.cc
index f00bbf50adf2..c8d4c448cd09 100644
--- a/device/vr/openxr/openxr_extension_handler_factories.cc
+++ b/device/vr/openxr/openxr_extension_handler_factories.cc
@@ -57,7 +57,9 @@ GetExtensionHandlerFactories() {
 
           new OpenXrStageBoundsProviderBasicFactory(),
 
+#if !BUILDFLAG(IS_LINUX)
           new OpenXrUnboundedSpaceProviderMsftFactory(),
+#endif
 
           new OpenXrSceneUnderstandingManagerMsftFactory(),
 
diff --git a/device/vr/openxr/openxr_graphics_binding.cc b/device/vr/openxr/openxr_graphics_binding.cc
index 522d3537439a..92fda5214b54 100644
--- a/device/vr/openxr/openxr_graphics_binding.cc
+++ b/device/vr/openxr/openxr_graphics_binding.cc
@@ -16,6 +16,8 @@ namespace device {
 #if BUILDFLAG(IS_WIN)
 SwapChainInfo::SwapChainInfo(ID3D11Texture2D* d3d11_texture)
     : d3d11_texture(d3d11_texture) {}
+#elif BUILDFLAG(IS_LINUX)
+SwapChainInfo::SwapChainInfo(VkImage image) : openxr_image(image) {}
 #elif BUILDFLAG(IS_ANDROID)
 SwapChainInfo::SwapChainInfo(uint32_t texture) : openxr_texture(texture) {}
 #endif
diff --git a/device/vr/openxr/openxr_graphics_binding.h b/device/vr/openxr/openxr_graphics_binding.h
index f2a45917e097..118d1d4176ef 100644
--- a/device/vr/openxr/openxr_graphics_binding.h
+++ b/device/vr/openxr/openxr_graphics_binding.h
@@ -24,6 +24,10 @@
 #include <wrl.h>
 #endif
 
+#if BUILDFLAG(IS_LINUX)
+#include "gpu/vulkan/vulkan_image.h"
+#endif
+
 #if BUILDFLAG(IS_ANDROID)
 #include "base/android/scoped_hardware_buffer_handle.h"
 #include "device/vr/android/local_texture.h"
@@ -50,6 +54,8 @@ struct SwapChainInfo {
  public:
 #if BUILDFLAG(IS_WIN)
   explicit SwapChainInfo(ID3D11Texture2D*);
+#elif BUILDFLAG(IS_LINUX)
+  explicit SwapChainInfo(VkImage image);
 #elif BUILDFLAG(IS_ANDROID)
   explicit SwapChainInfo(uint32_t texture);
 #endif
@@ -69,6 +75,10 @@ struct SwapChainInfo {
   // and D3D11Fence for each D3D11 texture in the vector.
   raw_ptr<ID3D11Texture2D> d3d11_texture = nullptr;
   Microsoft::WRL::ComPtr<ID3D11Fence> d3d11_fence;
+#elif BUILDFLAG(IS_LINUX)
+  VkImage openxr_image;
+  gfx::Size shared_buffer_size{0, 0};
+  std::unique_ptr<gpu::VulkanImage> local_vkimage;
 #elif BUILDFLAG(IS_ANDROID)
   // Ideally this would be a gluint, but there are conflicting headers for GL
   // depending on *how* you want to use it; so we can't use it at the moment.
@@ -79,7 +89,6 @@ struct SwapChainInfo {
   // The size of the texture used for the shared buffer; which may be different
   // than the size of the actual swapchain image, as this size is influenced by
   // any framebuffer scale factor that the page may request.
-  // This property isn't android-specific but it is currently unused on Windows.
   gfx::Size shared_buffer_size{0, 0};
 
   // This owns a single reference to an AHardwareBuffer object.
diff --git a/device/vr/openxr/openxr_platform.h b/device/vr/openxr/openxr_platform.h
index a0158be7f93c..65f0f32df748 100644
--- a/device/vr/openxr/openxr_platform.h
+++ b/device/vr/openxr/openxr_platform.h
@@ -18,6 +18,8 @@
 
 #if BUILDFLAG(IS_WIN)
 #include <d3d11.h>
+#elif BUILDFLAG(IS_LINUX)
+#include <vulkan/vulkan_core.h>
 #elif BUILDFLAG(IS_ANDROID)
 #include <EGL/egl.h>
 #include <jni.h>
diff --git a/device/vr/openxr/openxr_render_loop.cc b/device/vr/openxr/openxr_render_loop.cc
index 79d9b07d3dd3..d119c768b20e 100644
--- a/device/vr/openxr/openxr_render_loop.cc
+++ b/device/vr/openxr/openxr_render_loop.cc
@@ -50,6 +50,10 @@ device::mojom::XRRenderInfoPtr GetRenderInfo(
 
 }  // namespace
 
+#if BUILDFLAG(IS_LINUX)
+#include "device/vr/openxr/linux/openxr_graphics_binding_vulkan.h"
+#endif
+
 namespace device {
 
 OpenXrRenderLoop::OutstandingFrame::OutstandingFrame() = default;
@@ -375,8 +379,10 @@ void OpenXrRenderLoop::StartRuntimeFinish(
 
   mojo::PendingRemote<mojom::ImmersiveOverlay> overlay_remote;
 
+  #if !BUILDFLAG(IS_LINUX) // TODO: overlay support
   overlay_receiver_.reset();
   overlay_remote = overlay_receiver_.BindNewPipeAndPassRemote();
+  #endif
 
   CHECK(request_session_callback_);
   std::move(request_session_callback_)
@@ -816,10 +822,16 @@ void OpenXrRenderLoop::SubmitFrameDrawnIntoTexture(
   DVLOG(3) << __func__ << " frame_index=" << frame_index;
   gpu::gles2::GLES2Interface* gl = context_provider_->ContextGL();
   gl->WaitSyncTokenCHROMIUM(sync_token.GetConstData());
+  #if BUILDFLAG(IS_LINUX)
+  gl->Finish(); // CHROMIUM_gpu_fence isn't available on Linux
+  MarkFrameSubmitted(frame_index);
+  MaybeCompositeAndSubmit();
+  #else
   const GLuint id = gl->CreateGpuFenceCHROMIUM();
   context_provider_->ContextSupport()->GetGpuFence(
       id, base::BindOnce(&OpenXrRenderLoop::OnWebXrTokenSignaled,
                          weak_ptr_factory_.GetWeakPtr(), frame_index, id));
+  #endif
 }
 
 void OpenXrRenderLoop::OnWebXrTokenSignaled(
@@ -841,7 +853,7 @@ void OpenXrRenderLoop::OnWebXrTokenSignaled(
 #if BUILDFLAG(IS_WIN)
   SubmitFrameWithTextureHandle(frame_index, mojo::PlatformHandle(),
                                gpu::SyncToken());
-#elif BUILDFLAG(IS_ANDROID)
+#elif BUILDFLAG(IS_ANDROID) || BUILDFLAG(IS_LINUX)
   MarkFrameSubmitted(frame_index);
   MaybeCompositeAndSubmit();
 #endif
diff --git a/device/vr/openxr/openxr_render_loop.h b/device/vr/openxr/openxr_render_loop.h
index 5419f0349891..77a3c875ab51 100644
--- a/device/vr/openxr/openxr_render_loop.h
+++ b/device/vr/openxr/openxr_render_loop.h
@@ -38,7 +38,7 @@
 #include "third_party/openxr/src/include/openxr/openxr.h"
 #include "ui/gfx/geometry/rect_f.h"
 
-#if BUILDFLAG(IS_WIN)
+#if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
 #include "base/threading/thread.h"
 #endif
 
@@ -65,7 +65,7 @@ class XRThread : public base::android::JavaHandlerThread {
       : base::android::JavaHandlerThread(name) {}
   ~XRThread() override = default;
 };
-#elif BUILDFLAG(IS_WIN)
+#elif BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)
 class XRThread : public base::Thread {
  public:
   explicit XRThread(const char* name) : base::Thread(name) {}
diff --git a/device/vr/public/cpp/features.cc b/device/vr/public/cpp/features.cc
index 7adbf50bdb3c..5f32dba2205d 100644
--- a/device/vr/public/cpp/features.cc
+++ b/device/vr/public/cpp/features.cc
@@ -63,8 +63,8 @@ BASE_FEATURE(kUseTargetTexture2DForSharedBuffers,
 // Controls WebXR support for the OpenXR Runtime.
 BASE_FEATURE(kOpenXR,
              "OpenXR",
-             BUILDFLAG(IS_WIN) ? base::FEATURE_ENABLED_BY_DEFAULT
-                               : base::FEATURE_DISABLED_BY_DEFAULT);
+             (BUILDFLAG(IS_WIN) || BUILDFLAG(IS_LINUX)) ? base::FEATURE_ENABLED_BY_DEFAULT
+                                                        : base::FEATURE_DISABLED_BY_DEFAULT);
 
 // Some WebXR features may have been enabled for ARCore, but are not yet ready
 // to be plumbed up from the OpenXR backend. This feature provides a mechanism
diff --git a/gpu/command_buffer/service/shared_image/external_vk_image_gl_representation.cc b/gpu/command_buffer/service/shared_image/external_vk_image_gl_representation.cc
index 09a9ee597e5d..d147a6db0e93 100644
--- a/gpu/command_buffer/service/shared_image/external_vk_image_gl_representation.cc
+++ b/gpu/command_buffer/service/shared_image/external_vk_image_gl_representation.cc
@@ -9,6 +9,7 @@
 #include "base/logging.h"
 #include "base/memory/raw_ptr.h"
 #include "gpu/command_buffer/service/texture_manager.h"
+#include "gpu/command_buffer/service/skia_utils.h"
 #include "gpu/vulkan/vulkan_util.h"
 #include "ui/gl/gl_bindings.h"
 
@@ -148,6 +149,13 @@ void ExternalVkImageGLRepresentationShared::EndAccess() {
       backing_impl()->context_state()->MarkContextLost();
       return;
     }
+
+    { // HACK: prevents FD exhaustion due to WebXR semaphores not getting cleaned up in some cases
+      GrFlushInfo flush_info = {};
+      gpu::AddVulkanCleanupTaskForSkiaFlush(context_provider(), &flush_info);
+      backing_impl()->context_state()->gr_context()->flush(flush_info);
+      backing_impl()->context_state()->gr_context()->submit();
+    }
   }
   backing_impl()->EndAccess(readonly, std::move(external_semaphore),
                             /*is_gl=*/true);
diff --git a/third_party/openxr/BUILD.gn b/third_party/openxr/BUILD.gn
index aa8e9a109009..b0612f02f8d7 100644
--- a/third_party/openxr/BUILD.gn
+++ b/third_party/openxr/BUILD.gn
@@ -187,6 +187,13 @@ if (enable_openxr) {
         "XR_USE_PLATFORM_WIN32",
         "XR_USE_GRAPHICS_API_D3D11",
       ]
+    } else if (is_linux) {
+    defines = [
+        "XRLOADER_DISABLE_EXCEPTION_HANDLING",
+        "XR_OS_LINUX",
+        "XR_USE_GRAPHICS_API_VULKAN",
+        "HAVE_SECURE_GETENV",
+      ]
     } else {
       defines = [
         "XRLOADER_DISABLE_EXCEPTION_HANDLING",
diff --git a/ui/gfx/linux/gbm_wrapper.cc b/ui/gfx/linux/gbm_wrapper.cc
index 7a1ae26444f3..0f2e4772a3fc 100644
--- a/ui/gfx/linux/gbm_wrapper.cc
+++ b/ui/gfx/linux/gbm_wrapper.cc
@@ -433,8 +433,16 @@ class Device final : public ui::GbmDevice {
     struct gbm_bo* bo = gbm_bo_import(device_.get(), GBM_BO_IMPORT_FD_MODIFIER,
                                       &fd_data, gbm_flags);
     if (!bo) {
-      LOG(ERROR) << "nullptr returned from gbm_bo_import";
-      return nullptr;
+      if (gbm_flags & GBM_BO_USE_SCANOUT) {
+        gbm_flags &= ~GBM_BO_USE_SCANOUT;
+        bo = gbm_bo_import(device_.get(), GBM_BO_IMPORT_FD_MODIFIER, &fd_data,
+                           gbm_flags);
+      }
+
+      if (!bo) {
+        LOG(ERROR) << "nullptr returned from gbm_bo_import";
+        return nullptr;
+      }
     }
 
     return std::make_unique<Buffer>(bo, format, gbm_flags, handle.modifier,
